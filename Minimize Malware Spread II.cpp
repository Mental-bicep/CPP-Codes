class Solution {
public:
   int find(int x,vector<int> &par)
    {
        if(x==par[x]) return x;
        return par[x]=find(par[x],par);
    }
    
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        vector<int> par(graph.size()),rank(graph.size(),1);
        for(int i=0;i<par.size();++i) par[i]=i;
        unordered_set<int> st1;
        for(int ele:initial) st1.insert(ele);
        for(int i=0;i<graph.size();++i)
            for(int j=0;j<graph[0].size();++j)
                if(graph[i][j]==1 and st1.find(i)==st1.end() and st1.find(j)==st1.end()) 
                {
                    int lx=find(i,par);
                    int ly=find(j,par);
                    if(lx!=ly)
                    {
                        if(rank[lx]>rank[ly]) par[ly]=lx,rank[lx]+=rank[ly];
                        else par[lx]=ly,rank[ly]+=rank[lx];
                    }
                }
        
        unordered_map<int,unordered_set<int>> mp1;
        unordered_map<int,int> mp2;
        for(int ele:initial)
        {
            for(int j=0;j<graph[0].size();++j)
            {
                if(graph[ele][j]==1 and st1.find(j)==st1.end())
                {
                    int lx=find(j,par);
                    if(mp1[ele].find(lx)==mp1[ele].end()){
                        mp1[ele].insert(lx);
                        ++mp2[lx];
                    }
                    
                }
            }
        }
        int ans=0,maxsize=0;
        for(int ele:initial){
            int tempsum=0;
            for(int nbrs:mp1[ele])
            {
                if(mp2[nbrs]>1) continue;
                tempsum+=rank[nbrs];
            }
            if(tempsum>maxsize){
                maxsize=tempsum;
                ans=ele;
            }   
            else if(tempsum==maxsize  and ele<ans) ans=ele;
        }
        if(ans==0) return *min_element(initial.begin(),initial.end());
        return ans;
    }
};
